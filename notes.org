#+TITLE: Présidentielles 2012
#+PROPERTY: session *Rpresid*
#+PROPERTY: exports results
#+PROPERTY: cache no
#+OPTIONS: H:5 toc:5 num:t
#+INFOJS_OPT: view:content toc:nil


* Sources

** Résultats du premier tour de la présidentielle par commune

   Téléchargeable en format CSV sur le site de =data.gouv.fr= :

   http://www.data.gouv.fr/donnees/view/R%C3%A9sultats-par-commune-%C3%A9lection-pr%C3%A9sidentielle-2012---Tour-1-551758

   Données téléchargées dans =data/source.csv=.

** Problèmes sur les données

   3 communes avec 100% de votes blancs !
   - 10.Pont-sur-Seine
   - 31.Bourg-d'Oueil
   - 43.Lissac

   Les "bons" résultats" sont sur le site du Parisien :
   http://www.leparisien.fr/resultats/elections-presidentielle-2012-pont-sur-seine-10400.php
   http://www.leparisien.fr/resultats/elections-presidentielle-2012-lissac-43350.php
   http://www.leparisien.fr/resultats/elections-presidentielle-2012-bourg-d-oueil-31110.php

   *Edit :* En fait c'est normal, ce sont des bureaux de vote pour lesquels le
   conseil constitutionnel a annulé tous les suffrages.

   On supprime donc ces trois communes dans les données.

*** Message Seenthis

Les résultats du premier tour de l'élection présidentielle sont faux ?

Ok, je reconnais, l'accroche est un peu marketingo-mensongère. Mais quand
même, je bosse depuis un moment sur les résultats du premier tour de
l'élection présidentielle au niveau communes, qui sont téléchargeables sur
data.gouv.fr :

http://www.data.gouv.fr/donnees/view/R%C3%A9sultats-par-commune-%C3%A9lection-pr%C3%A9sidentielle-2012---Tour-1-551758?xtmc=%C3%A9lections+2012&xtcr=6

Et à force de te triturer ça dans tous les sens, j'ai fini par tomber sur
trois communes avec des résultats quelque peu curieux, à savoir 100% de
bulletins blancs. Les données ne sont pas bonnes sur le fichier CSV de
data.gouv.fr, mais aussi sur le site du Ministère de l'intérieur, pour les
communes suivantes :

- Pont-sur-Seine, dans l'Aube : http://elections.interieur.gouv.fr/PR2012/021/010/010298.html

- Bourg-d'Oueil, en Haute-Garonne : http://elections.interieur.gouv.fr/PR2012/073/031/031081.html

- Et Lissac, en Haute Loire : http://elections.interieur.gouv.fr/PR2012/083/043/043122.html

Il s'agit clairement d'une erreur. On la retrouve sur certains sites ayant
récupéré leurs résultats auprès du ministère, mais pas sur d'autres comme
Libération ou le Parisien :

http://www.leparisien.fr/resultats/elections-presidentielle-2012-pont-sur-seine-10400.php

Le problème, c'est que les chiffres offciels nationaux du ministère de
l'intérieur, et ceux validés par le conseil constituionnel, ont été calculés
avec ces trois erreurs. Si on fait la somme sur le fichier CSV de
data.gouv.fr, on obtient les mêmes chiffres que là :

http://www.gouvernement.fr/gouvernement/resultats-definitifs-du-premier-tour-de-l-election-presidentielle-2012-etablis-par-le-c

ou là :

http://elections.interieur.gouv.fr/PR2012/FE.html

Or donc, et sauf erreur toutjours possible de ma part, j'en déduis que les
résultats officiels du premier tour validés par le conseil constitutionnel
sont faux. Évidemment ça ne modifiera pas le résultat puisque ça représente au
total 976 inscrits, mais quand même.

Et pis moi va falloir que je refasse mouliner tous mes calculs, tiens.

#seenthis_scoop


* Init

#+begin_src R :results output :exports both
  library(maptools)
  library(rgdal)
  library(foreign)
  library(stringr)
  library(ggplot2)
  library(rgrs)
  library(ade4)
  library(FactoMineR)
  library(grid)
  library(flashClust)
  library(reshape2)
#+end_src

#+RESULTS:
#+begin_example
Le chargement a nécessité le package : foreign
Le chargement a nécessité le package : sp
Le chargement a nécessité le package : lattice
Checking rgeos availability: TRUE
Geospatial Data Abstraction Library extensions to R successfully loaded
Loaded GDAL runtime: GDAL 1.7.3, released 2010/11/10
Path to GDAL shared files: /usr/share/gdal/1.7
Loaded PROJ.4 runtime: Rel. 4.7.1, 23 September 2009, [PJ_VERSION: 470]
Path to PROJ.4 shared files: (autodetected)
R> R> R> R> 
Attachement du package : ‘ade4’

The following object(s) are masked from ‘package:base’:

    within
Le chargement a nécessité le package : ellipse
Le chargement a nécessité le package : cluster
Le chargement a nécessité le package : scatterplot3d

Attachement du package : ‘FactoMineR’

The following object(s) are masked from ‘package:ade4’:

    reconst
R> 
Attachement du package : ‘flashClust’

The following object(s) are masked from ‘package:stats’:

    hclust
#+end_example

* Chargement et recodages

** Chargement

#+begin_src R :results output :exports both

  ds <- read.csv("data/source.csv")

#+end_src  

#+RESULTS:

** Recodages

#+begin_src R :results output :exports both
   
  d <- data.frame(nom=ds$Libellé.de.la.commune,dpt=ds$Code.du.département,com=ds$Code.de.la.commune)
  
  ## Padding des identifiants
  d$dpt <- str_pad(d$dpt, width=2, pad="0", side="left")
  d$com <- str_pad(d$com, width=3, pad="0", side="left")
  ## Identifiant INSEE
  d$id.com <- paste(d$dpt, d$com, sep="")
  ## Rownames
  rownames(d) <- paste0(d$dpt,".",d$nom)
  
  ## Renommages
  d$inscr <- ds$Inscrits
  d$voix.abst <- ds$Abstentions
  d$votants <- ds$Votants
  d$voix.blancs <- ds$Blancs.et.nuls
  d$voix.joly <- ds$Voix
  d$voix.lepen <- ds$Voix.1
  d$voix.sarkozy <- ds$Voix.2
  d$voix.melenchon <- ds$Voix.3
  d$voix.poutou <- ds$Voix.4
  d$voix.arthaud <- ds$Voix.5
  d$voix.cheminade <- ds$Voix.6
  d$voix.bayrou <- ds$Voix.7
  d$voix.dupont_aignan <- ds$Voix.8
  d$voix.hollande <- ds$Voix.9
  
  ## Suppression des Collectivités d'outre-mer et français de l'étranger
  ## on ne garde que les DOM
  d <- d[!(d$dpt %in% c("ZN","ZP","ZS","ZW","ZX","ZZ")),]  
  
  ## Suppression des 3 communes annulées par le conseil constitutionnel
  d <- d[!(rownames(d) %in% c("10.Pont-sur-Seine","31.Bourg-d'Oueil","43.Lissac")),]
  
  ## Calcul des variables de pourcentage
  d$abst <- d$voix.abst / d$inscr * 100
  noms <- c("blancs","joly","lepen","sarkozy","melenchon","poutou","arthaud","cheminade","bayrou","dupont_aignan","hollande") 
  for (nom in noms) {
    d[,nom] <- d[,paste0("voix.",nom)] / d$votants * 100
  }
  
#+end_src

#+RESULTS:

** Tris à plat


   #+caption: Votes Le Pen
   #+attr_latex: width=\textwidth
   #+label: fig:lepen
   #+begin_src R :results graphics :file tmp/fig_lepen.png
     qplot(d$lepen)
   #+end_src

   #+RESULTS:
   [[file:tmp/fig_lepen.png]]

   #+begin_src R :results output :exports both
     range(d$abst)
   #+end_src

   #+RESULTS:
   : [1]  0.0000 81.5161

   #+begin_src R :results output :exports both
     range(d$blancs)
   #+end_src

   #+RESULTS:
   : [1]  0.00000 25.34113


* ACP non normée

** Analyse

#+begin_src R :results output :exports both
  
  vars.acp <- c("abst","blancs","joly","lepen","sarkozy","melenchon","poutou","arthaud","cheminade","bayrou","dupont_aignan","hollande")
  
  acp.nn <- PCA(d[,vars.acp], scale.unit=FALSE,ncp=12, graph=FALSE)
  
#+end_src

#+RESULTS:

   
** Graphiques

Histogramme des valeurs propres

#+begin_src R :results graphics  :exports results
  tmp <- data.frame(id=factor(1:nrow(acp.nn$eig)),val=acp.nn$eig$`percentage of variance`)
  qplot(data=tmp, x=id, y=val, geom="bar", stat="identity") +
     opts(title="Valeurs propres") +
     xlab("Axe") +
     ylab("Pourcentage de variance")
#+end_src

#+RESULTS:

Variables

#+begin_src R :results output :exports both
  plot(acp.nn, axes=c(6,7), choix="var")
#+end_src

#+RESULTS:

Individus

#+begin_src R :results output :exports both
  plot(acp.nn, axes=c(6,7), choix="ind")
#+end_src

#+RESULTS:

Variables (ggplot2)

#+begin_src R :results graphics  :exports results
    tmp <- data.frame(acp.nn$var$coord)
    l <- 1 - (0.25 * sqrt(1/with(tmp,Dim.1^2 + Dim.2^2)))
    ggplot() +
      geom_hline(yintercept=0, alpha=I(0.5)) +
      geom_vline(xintercept=0, alpha=I(0.5)) +
      geom_segment(data=tmp, aes(xend=tmp$Dim.1 * l, yend=tmp$Dim.2 * l), x=0, y=0, arrow=arrow(angle=25, length=unit(0.25, "cm")), color="RoyalBlue") +
      geom_text(data=tmp, aes(x=tmp$Dim.1, y=tmp$Dim.2, label=rownames(tmp)), size=I(3)) +
      xlab("Axe 1") +
      ylab("Axe 2") +
      labs(colour="Variables") +
      coord_equal()
#+end_src

#+RESULTS:

#+RESULTS:

** Export

#+begin_src R :results output :exports none
nb.axes <- 11
#+end_src

#+RESULTS:

On effectue une classification à partir des données résultant de l'analyse
précédente, et en ne conservant que les src_R{nb.axes} premiers axes.

#+begin_src R :results output :exports both
  tmp.nn <- data.frame(acp.nn$ind)
  tmp.nn <- tmp.nn[,1:nb.axes] 
  
  save(tmp.nn, file="ec2/in/tmp_non_normee.rda")

#+end_src

#+RESULTS:



* ACP normée

** Analyse

#+begin_src R :results output :exports both
  
  vars.acp <- c("abst","blancs","joly","lepen","sarkozy","melenchon","poutou","arthaud","cheminade","bayrou","dupont_aignan","hollande")
  
  acp.n <- PCA(d[,vars.acp], scale.unit=TRUE, graph=FALSE, ncp=12)
  
#+end_src

#+RESULTS:

** Graphiques

Histogramme des valeurs propres

#+begin_src R :results graphics  :exports results
  tmp <- data.frame(id=factor(1:nrow(acp.n$eig)),val=acp.n$eig$`percentage of variance`)
  qplot(data=tmp, x=id, y=val, geom="bar", stat="identity") +
     opts(title="Valeurs propres") +
     xlab("Axe") +
     ylab("Pourcentage de variance")
#+end_src

#+RESULTS:

Variables

#+begin_src R :results output :exports both
  plot(acp.n, axes=c(1,2), choix="var")
#+end_src

#+RESULTS:

Individus

#+begin_src R :results output :exports both
  plot(acp.n, axes=c(6,7), choix="ind")
#+end_src

** Export


#+begin_src R :results output :exports none
nb.axes <- 11
#+end_src

#+RESULTS:

On effectue une classification à partir des données résultant de l'analyse
précédente, et en ne conservant que les src_R{nb.axes} premiers axes.

#+begin_src R :results output :exports both
  tmp.n <- data.frame(acp.n$ind)
  tmp.n <- tmp.n[,1:nb.axes] 
  
  save(tmp.n, file="ec2/in/tmp_normee.rda")

#+end_src

#+RESULTS:


* Classification

** Fonctions

#+begin_src R :results output :exports both
  
  grplot <- function (varname, vgroupes, title="") {
    tmp <- data.frame(groupes=vgroupes, var=d[,varname])
    ggplot(data=tmp, aes(x=groupes, y=var))  +
      geom_hline(yintercept=median(tmp$var), colour="red") +
      geom_violin(aes(fill=groupes, colour=groupes), alpha=0.6) +
      geom_boxplot(aes(fill=groupes), outlier.colour=NA) +
      opts(title=varname, legend.position="none") + xlab("Groupe") + ylab("Pourcentage") +
      scale_fill_brewer(palette="Set3") + scale_colour_brewer(palette="Set3")
  }
  
  difftests <- function(var, groupes, seuil=0.05) {
    v <- sapply(levels(groupes), function(i) {
      var.values <- var[groupes==i]
      diff.mean <- round(mean(var.values)-mean(var),2)
      if (length(var.values)<2) p.mean <- 0
      else p.mean <- t.test(var ~ groupes==i)$p.value
      if (p.mean > seuil) diff.mean <- NA
      return(diff.mean) })        
    names(v) <- levels(groupes)
    v
  }
  
  diffmatrix <- function(vars, groupes, seuil=0.05) {
    m <- sapply(vars, function(name) {
      difftests(d[,name], groupes, seuil=seuil)
    })
    t(m)
  }
  
  vars <- c("lepen","sarkozy","dupont_aignan","bayrou","hollande", "joly","melenchon","poutou","arthaud","cheminade", "blancs","abst")
  labels <- c("Le Pen","Sarkozy","Dupont-Aignan","Bayrou","Hollande", "Joly","Mélenchon","Poutou","Arthaud","Cheminade", "Blancs","Abstention")
  
  diffmatrix.plot <- function(m, seuil.diff=0, title=NULL) {
    mm <- melt(m)
    mm$Var1 <- factor(mm$Var1, levels=vars, labels=labels)
    mm$value[abs(mm$value) < seuil.diff] <- NA
    ggplot(data=subset(mm, !is.na(value))) +
        geom_tile(aes(x=Var1, y=Var2,fill=value), colour="white") +
        scale_fill_gradient2(low="blue", mid="white", high="red") +
        geom_text(aes(x=Var1, y=Var2,label=value), size=2.5) +
        scale_y_continuous(breaks=1:max(mm$Var2)) +
        opts(axis.text.x=theme_text(angle=45,hjust=1,vjust=1)) +
        xlab("") + ylab("Groupe") + opts(title=title)
   }
   
  diffmatrix.barplot <- function(m) {
    mm <- melt(m)
    mm$Var1 <- factor(mm$Var1, levels=vars, labels=labels)
    qplot(data=mm,x=Var1, y=value, geom="bar", stat="identity") + 
      geom_hline(yintercept=0, colour="grey80") + 
      facet_grid(Var2~.)
  }
   
#+end_src  

#+RESULTS:


** Classification sur données brutes
*** Export
    
#+begin_src R :results output :exports both
  vars <- c("abst","blancs","joly","lepen","sarkozy","melenchon","poutou","arthaud","cheminade","bayrou","dupont_aignan","hollande")
  tmp.brut <- d[,vars]
  save(tmp.brut, file="ec2/in/tmp_brut.rda")
#+end_src

#+RESULTS:

*** Ward et détermination du nombre de classes

#+caption: 
#+attr_latex: width=\textwidth
#+label: dendro_brut_ward
#+begin_src R :results graphics :file tmp/dendro_brut_ward.pdf
  
  load("ec2/out/hc_brut_ward.rda")
  
  plclust(hc.brut.ward,labels=FALSE,hang=0)
  
#+end_src

#+RESULTS:
[[file:tmp/dendro_brut_ward.pdf]]

#+begin_src R :results output :exports both
   
  nb.classes.brut <- 9
  
  # for (nb.classes.brut in 2:30) {
  #   groupes.brut <- factor(cutree(hc.brut.ward, k=nb.classes.brut))
  #   table(groupes.brut)
  
  #   m.brut <- diffmatrix(vars, groupes.brut, seuil=0.001)
  #   pdf(file=paste("tmp/diffmatrix_brut_",nb.classes.brut,".pdf",sep=""))
  #   print(diffmatrix.plot(m.brut, seuil.diff=0.5, title=paste("Normée", "Ward", nb.classes.brut, sep=" - ")))
  #   dev.off()
  # }
  
  groupes.brut <- factor(cutree(hc.brut.ward, k=nb.classes.brut))
  table(groupes.brut)
  
  m.brut <- diffmatrix(vars, groupes.brut, seuil=0.001)
  diffmatrix.plot(m.brut, seuil.diff=0.5, title=paste("Brute", "Ward", nb.classes.brut, sep=" - "))
  
  
  
#+end_src

#+RESULTS:
: R> R> R> R> R> R> R> R> R> R> R> R> R> groupes.brut
:    1    2    3    4    5    6    7    8    9 
: 7507 6996 4838 2326 3211 3195 1991 3507 3120


*** Description d'une classe

#+begin_src R :results output :exports both
  
  grplot("lepen", groupes.brut)
  
  groupe <- 1
  
  dv <- d[,vars]
  moyennes <- apply(dv, 2, mean)
  moyennes
  dv <- sweep(dv, 2, moyennes)
  dv$groupes <- groupes.brut
  
  
  dvm <- melt(dv)
  
  str(dvm)
  
  tmp <- dvm[dvm$groupes==groupe,]
  
  ggplot(data=tmp, aes(x=variable, y=value)) +
    geom_violin(aes(fill=variable, colour=variable), alpha=0.6, width=5) +
    #geom_boxplot(aes(fill=variable), outlier.colour=NA) +
    opts(title="", legend.position="none") + xlab("Groupe") + ylab("Pourcentage") +
    scale_fill_brewer(palette="Set3") + scale_colour_brewer(palette="Set3")
  
#+end_src






    
** Classification sur ACP non normée

Les calculs de distance et de classification sont effectués via une instance EC2.

*** Ward et détermination du nombre de classes

#+caption: 
#+attr_latex: width=\textwidth
#+label: dendro_nn_ward
#+begin_src R :results graphics :file tmp/dendro_nn_ward.pdf
  
  load("ec2/out/hc_nn_ward.rda")
  
  plclust(hc.nn.ward,labels=FALSE,hang=0)
  
#+end_src

#+RESULTS:
[[file:tmp/dendro_nn_ward.pdf]]

#+begin_src R :results output :exports both
   
  nb.classes.nn <- 9
  
  # for (nb.classes.nn in 2:30) {
  #   groupes.nn <- factor(cutree(hc.nn.ward, k=nb.classes.nn))
  #   table(groupes.nn)
  
  #   m.nn <- diffmatrix(vars, groupes.nn, seuil=0.001)
  #   pdf(file=paste("tmp/diffmatrix_nn_",nb.classes.nn,".pdf",sep=""))
  #   print(diffmatrix.plot(m.nn, seuil.diff=0.5, title=paste("Normée", "Ward", nb.classes.nn, sep=" - ")))
  #   dev.off()
  # }
  
  groupes.nn <- factor(cutree(hc.nn.ward, k=nb.classes.nn))
  table(groupes.nn)
  
  m.nn <- diffmatrix(vars, groupes.nn, seuil=0.001)
  diffmatrix.plot(m.nn, seuil.diff=0.5, title=paste("Non normée", "Ward", nb.classes.nn, sep=" - "))
  
  
  
#+end_src

#+RESULTS:
: R> R> R> R> R> R> R> R> R> R> R> R> R> groupes.nn
:    1    2    3    4    5    6    7    8    9 
: 7507 6996 4838 2326 3211 3195 1991 3507 3120


*** Description d'une classe

#+begin_src R :results output :exports both
  
  grplot("lepen", groupes.nn)
  
  groupe <- 1
  
  dv <- d[,vars]
  moyennes <- apply(dv, 2, mean)
  moyennes
  dv <- sweep(dv, 2, moyennes)
  dv$groupes <- groupes.nn
  
  
  dvm <- melt(dv)
  
  str(dvm)
  
  tmp <- dvm[dvm$groupes==groupe,]
  
  ggplot(data=tmp, aes(x=variable, y=value)) +
    geom_violin(aes(fill=variable, colour=variable), alpha=0.6, width=5) +
    #geom_boxplot(aes(fill=variable), outlier.colour=NA) +
    opts(title="", legend.position="none") + xlab("Groupe") + ylab("Pourcentage") +
    scale_fill_brewer(palette="Set3") + scale_colour_brewer(palette="Set3")
  
#+end_src

#+RESULTS:
: R>  [1] "lepen"         "sarkozy"       "dupont_aignan" "bayrou"       
:  [5] "hollande"      "joly"          "melenchon"     "poutou"       
:  [9] "arthaud"       "cheminade"     "blancs"        "abst"


*** Archives							    :ARCHIVE:
**** ABANDONNÉ Single

#+caption: 
#+attr_latex: width=\textwidth
#+label: dendro_nn_single
#+begin_src R :results graphics :file tmp/dendro_nn_single.pdf
  
  load("ec2/out/hc_nn_single.rda")
  
  plclust(hc.nn.single,labels=FALSE,hang=0)
  
#+end_src

#+RESULTS:
[[file:tmp/dendro_nn_single.pdf]]

#+begin_src R :results output :exports both
  nb.classes <- 25
  
  groupes <- factor(cutree(hc.nn.single, k=nb.classes))
  table(groupes)
  m <- diffmatrix(vars, groupes, seuil=0.01)
  diffmatrix.plot(m)
  
#+end_src




** Classification sur ACP normée

Les calculs de distance et de classification sont effectués via une instance
EC2.

*** Ward

#+caption: 
#+attr_latex: width=\textwidth
#+label: dendro_n_ward
#+begin_src R :results graphics :file tmp/dendro_n_ward.pdf

  load("ec2/out/hc_n_ward.rda")

  plclust(hc.n.ward,labels=FALSE,hang=0)

#+end_src

#+RESULTS:
[[file:tmp/dendro_n_ward.pdf]]

#+begin_src R :results output :exports both
  
  nb.classes.n <- 16
  
  # for (nb.classes.n in 2:30) {
  #   groupes.n <- factor(cutree(hc.n.ward, k=nb.classes.n))
  #   table(groupes.n)
  
  #   m.n <- diffmatrix(vars, groupes.n, seuil=0.001)
  #   pdf(file=paste("tmp/diffmatrix_",nb.classes.n,".pdf",sep=""))
  #   print(diffmatrix.plot(m.n, seuil.diff=0.5, title=paste("Normée", "Ward", nb.classes.n, sep=" - ")))
  #   dev.off()
  # }
  
  groupes.n <- factor(cutree(hc.n.ward, k=nb.classes.n))
  table(groupes.n)
  
  m.n <- diffmatrix(vars, groupes.n, seuil=0.001)
  diffmatrix.plot(m.n, seuil.diff=0.5, title=paste("Normée", "Ward", nb.classes.n, sep=" - "))
  
  
#+end_src

#+RESULTS:
: R> R> R> R> R> R> R> R> R> R> R> R> R> groupes.n
:    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15 
: 5136 1434 3803 5637 2742 1415 1951 2306 1863 1247 1590 2044 1080 3387  920 
:   16 
:  136


*** Archives							    :ARCHIVE:
**** ABANDONNÉ Average

#+caption: 
#+attr_latex: width=\textwidth
#+label: dendro_n_average
#+begin_src R :results graphics :file tmp/dendro_n_average.pdf

  load("ec2/out/hc_n_average.rda")

  plclust(hc.n.average,labels=FALSE,hang=0)

#+end_src

#+RESULTS:
[[file:tmp/dendro_n_average.pdf]]

**** ABANDONNÉ Single

#+caption: 
#+attr_latex: width=\textwidth
#+label: dendro_n_single
#+begin_src R :results graphics :file tmp/dendro_n_single.pdf

  load("ec2/out/hc_n_single.rda")

  plclust(hc.n.single,labels=FALSE,hang=0)

#+end_src

#+RESULTS:
[[file:tmp/dendro_n_single.pdf]]

**** ABANDONNÉ Complete

#+caption: 
#+attr_latex: width=\textwidth
#+label: dendro_n_complete
#+begin_src R :results graphics :file tmp/dendro_n_complete.pdf

  load("ec2/out/hc_n_complete.rda")

  plclust(hc.n.complete,labels=FALSE,hang=0)

#+end_src

#+RESULTS:
[[file:tmp/dendro_n_complete.pdf]]

#+begin_src R :results output :exports both
  nb.classes <- 30
  
  groupes <- factor(cutree(hc.n.complete, k=nb.classes))
  table(groupes)
  
  m <- diffmatrix(vars, groupes, seuil=0.01)
  diffmatrix.plot(m)
  
#+end_src

**** ABANDONNÉ Median

#+caption: 
#+attr_latex: width=\textwidth
#+label: dendro_n_median
#+begin_src R :results graphics :file tmp/dendro_n_median.pdf

  load("ec2/out/hc_n_median.rda")

  plclust(hc.n.median,labels=FALSE,hang=0)

#+end_src

#+RESULTS:
[[file:tmp/dendro_n_median.pdf]]



**** ABANDONNÉ Mcquitty

#+caption: 
#+attr_latex: width=\textwidth
#+label: dendro_n_mcquitty
#+begin_src R :results graphics :file tmp/dendro_n_mcquitty.pdf

  load("ec2/out/hc_n_mcquitty.rda")

  plclust(hc.n.mcquitty,labels=FALSE,hang=0)

#+end_src

#+RESULTS:
[[file:tmp/dendro_n_mcquitty.pdf]]


**** ABANDONNÉ Centroid

#+caption: 
#+attr_latex: width=\textwidth
#+label: dendro_n_centroid
#+begin_src R :results graphics :file tmp/dendro_n_centroid.pdf

  load("ec2/out/hc_n_centroid.rda")

  plclust(hc.n.centroid,labels=FALSE,hang=0)

#+end_src

#+RESULTS:
[[file:tmp/dendro_n_centroid.pdf]]





* Essai de carte

#+caption: Test carte classification
#+attr_latex: width=\textwidth
#+label: carte_classif
 #+begin_src R :results graphics :file tmp/carte_classif.pdf
   load(file = "data/com_points.rda") ## com.points
   
rhone <- com.points[com.points@data$CODE_DEPT=="69",]
   
   str(rhone@data)
   
   gpclibPermit()
   rhone@data$id <-  rhone@data$INSEE_COM
   rhone.ggmap <- fortify(rhone, region="id")
   
   
   
#+end_src

 #+RESULTS:
 [[file:tmp/carte_classif.pdf]]

** Fusion tables

Export pour Fusion tables :

#+begin_src R :results none
  load(file = "data/rgc.rda") ## com.points
  
  tmp.rgc <- rgc[,c("id","long","lat")]
  tmp.d <- d[,c("nom","id.com", vars)]
  tmp.d$groupes <- groupes.nn
  tmp.d[,vars] <- round(tmp.d[,vars],1)
  
  geo <- merge(tmp.rgc, tmp.d, by.x="id", by.y="id.com", all.x=FALSE, all.y=FALSE)
  geo$marker[geo$groupes==1] <- "ltblu_circle"
  geo$marker[geo$groupes==2] <- "purple_circle"
  geo$marker[geo$groupes==3] <- "grn_circle"
  geo$marker[geo$groupes==4] <- "red_circle"
  geo$marker[geo$groupes==5] <- "orange_circle"
  geo$marker[geo$groupes==6] <- "pink_circle"
  geo$marker[geo$groupes==7] <- "ylw_circle"
  geo$marker[geo$groupes==8] <- "blu_circle"
  geo$marker[geo$groupes==9] <- "wht_circle"
  
  write.csv(geo, file="out/export_fusion_table.csv")
  
#+end_src

#+RESULTS:

Code HTML info-window :

#+begin_src html
<div class='googft-info-window' style='font-family: sans-serif'>
<h3>{nom}</h3>
<p><b>Groupe {groupes}</b></p>
<table>
<tr><td>Le Pen</td><td>{lepen}%</td></tr>
<tr><td>Sarkozy</td><td>{sarkozy}%</td></tr>
<tr><td>Dupont-Aignan</td><td>{dupont_aignan}%</td></tr>
<tr><td>Bayrou</td><td>{bayrou}%</td></tr>
<tr><td>Hollande</td><td>{hollande}%</td></tr>
<tr><td>Joly</td><td>{joly}%</td></tr>
<tr><td>Mélenchon</td><td>{melenchon}%</td></tr>
<tr><td>Poutou</td><td>{poutou}%</td></tr>
<tr><td>Arthaud</td><td>{arthaud}%</td></tr>
<tr><td>Cheminade</td><td>{cheminade}%</td></tr>
<tr><td>Blancs et nuls</td><td>{blancs}%</td></tr>
<tr><td>Abstention</td><td>{abst}%</td></tr>
</table>
</div>
#+end_src




#+begin_src R :results output :exports both
    fr <- map_data("france")
    
  ggplot(data=geo, aes(long,lat)) +
    borders("france", size=0.3, colour="grey30") +
    geom_point(aes(color=groupes),size=0.6) +
    theme_bw() +
    coord_map() +
    facet_wrap(~groupes) +
    opts(legend.position="none",
         axis.ticks = theme_blank(), 
         axis.title.y = theme_blank(), 
         axis.text.y =  theme_blank(),
         axis.title.x = theme_blank(), 
         axis.text.x =  theme_blank()) 
    
  
      
    
    
#+end_src

#+RESULTS:



